<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WE - Stable Version</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #fdfdf0; 
            font-family: "Microsoft YaHei", sans-serif;
            touch-action: manipulation;
        }

        .container {
            position: relative; width: 100vw; height: 100vh;
            display: flex; align-items: center; justify-content: flex-start;
        }

        /* 桌面端布局：文字在左，树在右 */
        .content-left {
            width: 45%; padding-left: 8%; z-index: 10; pointer-events: none;
            position: relative;
        }
        .content-left h1 { font-size: 2.2rem; color: #333; margin-bottom: 30px; }
        .content-left p {
            font-size: 1rem; color: #555; line-height: 2.2; margin: 0;
            letter-spacing: 1px; opacity: 0; animation: fadeInText 2s ease forwards;
        }

        /* 移动端适配：文字在上，树在下 */
        @media (max-width: 768px) {
            .container { flex-direction: column; align-items: center; }
            .content-left { 
                width: 90%; padding: 12% 0 0 0; text-align: center; 
            }
            .content-left h1 { font-size: 1.6rem; margin-bottom: 15px; }
            .content-left p { font-size: 0.85rem; line-height: 1.8; }
        }

        @keyframes fadeInText {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #treeCanvas { position: absolute; top: 0; left: 0; z-index: 5; }

        .horizon {
            position: absolute; bottom: 20%; left: 0; right: 0;
            height: 2px; background-color: #333; z-index: 2;
        }

        .ground-petal {
            position: absolute; z-index: 6; cursor: pointer;
            transition: top 0.5s cubic-bezier(0.25, 0.8, 0.25, 1), transform 0.5s ease;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.1)); 
            transform-origin: center bottom;
        }

        .modal {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%); z-index: 2000;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            padding: 20px; border-radius: 24px; border: 1px solid rgba(255,255,255,0.5);
            box-shadow: 0 25px 50px rgba(0,0,0,0.15); text-align: center;
            width: 85%; max-width: 350px;
        }
        .modal.active { display: block; animation: zoomIn 0.3s ease; }
        .modal img { width: 100%; border-radius: 16px; border: 4px solid white; box-sizing: border-box; }
        .modal p { color: #333; margin-top: 15px; font-weight: bold; font-size: 16px; }
        
        @keyframes zoomIn { from { transform: translate(-50%, -50%) scale(0.9); opacity: 0; } }
        .overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.3); z-index: 1999; }
    </style>
</head>
<body>

    <div class="overlay" id="overlay"></div>
    <div class="modal" id="modal">
        <img id="mImg" src="" alt="Memory">
        <p id="mTitle"></p>
    </div>

    <div class="container" id="mainContainer">
        <div class="content-left">
            <h1>Hello, 陌生人。</h1>
            <p>纪念我们第一次跨年</p>
            <p>祝我们永远如初</p>
            <p>祝我们永远幸福</p>
            <p>像第一次见你那样</p>
            <p>第一、第二次跨年</p>
            <p>以后都是我们</p>
        </div>
        <div class="horizon"></div>
        <canvas id="treeCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');
        const modal = document.getElementById('modal');
        const overlay = document.getElementById('overlay');
        const mImg = document.getElementById('mImg');
        const mTitle = document.getElementById('mTitle');
        
        let width, height, treeX, treeY, treeScale;
        let staticLeaves = [], fallingLeaves = [], groundHeightMap = [];
        
        const photoGallery = [
            { url: '1.jpg', title: '第一次跨年' },
            { url: '4.jpg', title: '最美的你' },
            { url: '3.jpg', title: '最可爱的也是你' },
            { url: '2.jpg', title: '幸福的我们' },
            { url: '5.jpg', title: '真的好幸福' }
        ];
        
        let photosToDrop = [];
        const colorPalette = [
            { fill: '#ff69b4', stroke: '#ff1493' }, { fill: '#ffb6c1', stroke: '#ff85a1' }, 
            { fill: '#ff4500', stroke: '#d13400' }, { fill: '#ffd700', stroke: '#ffcc00' }, 
            { fill: '#fb6f92', stroke: '#ff4d6d' }  
        ];

        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            groundHeightMap = new Array(width).fill(0);
            
            // --- 核心修复：绝对坐标算法 ---
            if (width > 768) {
                treeX = width * 0.7; 
                treeY = height * 0.8;
                treeScale = Math.max(width / 1300, 0.8); // 确保在小屏电脑上也足够大
            } else {
                treeX = width * 0.5; 
                treeY = height * 0.85;
                treeScale = Math.max(width / 400, 0.7); // 确保在手机上足够醒目
            }
            
            photosToDrop = [...photoGallery];
            generateStaticLeaves();
            animate();
        }

        function generateStaticLeaves() {
            staticLeaves = [];
            const count = width > 768 ? 1600 : 800;
            for (let i = 0; i < count; i++) {
                const t = Math.random() * Math.PI * 2;
                // 增大半径范围，确保树冠茂密
                const r = Math.pow(Math.random(), 0.5) * (260 * treeScale); 
                const lx = treeX + 16 * Math.pow(Math.sin(t), 3) * (r / 15);
                const ly = (treeY - 330 * treeScale) - (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * (r / 15);
                
                // 修正判定范围，确保叶子不长到树根
                if (ly < treeY - 130 * treeScale) {
                    staticLeaves.push({ 
                        x: lx, y: ly, size: (Math.random() * 8 + 4) * treeScale, 
                        colors: colorPalette[Math.floor(Math.random() * colorPalette.length)], 
                        angle: Math.random() * Math.PI, 
                        swing: Math.random() * Math.PI * 2 
                    });
                }
            }
        }

        function drawTrunk() {
            ctx.fillStyle = '#1a1a1a';
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineCap = 'round';
            
            const bW = 20 * treeScale;
            const bH = 200 * treeScale;

            ctx.beginPath();
            ctx.moveTo(treeX - bW, treeY);
            // 加强主干的曲线弧度
            ctx.quadraticCurveTo(treeX, treeY - bH/2, treeX - bW/4, treeY - bH); 
            ctx.lineTo(treeX + bW/4, treeY - bH); 
            ctx.quadraticCurveTo(treeX + bW/2, treeY - bH/2, treeX + bW*1.5, treeY); 
            ctx.fill();

            // 绘制更稳固的支撑分叉
            const branches = [
                {s: [treeX, treeY-140*treeScale], e: [treeX-70*treeScale, treeY-250*treeScale], w: 6*treeScale},
                {s: [treeX, treeY-130*treeScale], e: [treeX+80*treeScale, treeY-240*treeScale], w: 5*treeScale}
            ];
            branches.forEach(b => {
                ctx.lineWidth = b.w;
                ctx.beginPath();
                ctx.moveTo(b.s[0], b.s[1]);
                ctx.quadraticCurveTo(b.s[0] + (b.e[0]-b.s[0])/2, b.s[1]-30*treeScale, b.e[0], b.e[1]);
                ctx.stroke();
            });
        }

        function animate() {
            // 清除上一帧
            ctx.clearRect(0, 0, width, height);
            const time = Date.now() * 0.0008;
            
            // 1. 先画树干
            drawTrunk();

            // 2. 画静态树叶
            staticLeaves.forEach(l => {
                const s = Math.sin(time + l.swing) * 1.5;
                drawHeart(l.x + s, l.y + s, l.size, l.colors, 0.85, l.angle);

                // 随机掉落
                if (photosToDrop.length > 0 && Math.random() > 0.996) { 
                    const data = photosToDrop.shift();
                    fallingLeaves.push({
                        x: l.x, y: l.y, size: l.size, colors: l.colors,
                        angle: l.angle, vx: (Math.random() * 0.8 - 0.4), vy: 1.8, 
                        phase: Math.random() * Math.PI * 2, memory: data 
                    });
                }
            });

            // 3. 画掉落的叶子
            for (let i = fallingLeaves.length - 1; i >= 0; i--) {
                let p = fallingLeaves[i];
                p.vy += 0.04; p.x += p.vx + Math.sin(time * 3 + p.phase) * 0.6; p.y += p.vy; p.angle += 0.05;
                let curX = Math.floor(p.x);
                if (curX >= 0 && curX < width) {
                    let gLevel = treeY - groundHeightMap[curX];
                    if (p.y >= gLevel) {
                        // 落地逻辑
                        if (Math.abs(p.x - treeX) < 250 * treeScale) {
                            createGroundPetal(p.x, gLevel, p.size, p.colors.fill, p.angle, p.memory);
                            // 堆积
                            for(let k=-12; k<=12; k++){
                                if(curX+k >=0 && curX+k < width) groundHeightMap[curX+k] += 2.5 * Math.exp(-(k*k)/45);
                            }
                        }
                        fallingLeaves.splice(i, 1);
                        continue;
                    }
                }
                drawHeart(p.x, p.y, p.size, p.colors, 0.9, p.angle);
            }
            requestAnimationFrame(animate);
        }

        function drawHeart(x, y, size, col, alpha, ang) {
            ctx.save(); ctx.translate(x, y); ctx.rotate(ang); ctx.globalAlpha = alpha;
            const g = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            g.addColorStop(0, col.fill); g.addColorStop(1, col.stroke);
            ctx.beginPath(); ctx.moveTo(0, 0);
            ctx.bezierCurveTo(-size/2, -size/2, -size, size/3, 0, size);
            ctx.bezierCurveTo(size, size/3, size/2, -size/2, 0, 0);
            ctx.fillStyle = g; ctx.fill(); ctx.restore();
        }

        function createGroundPetal(x, y, size, col, ang, mem) {
            const img = document.createElement('img');
            img.src = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="-20 -20 40 40"><path d="M0,0 C-10,-10 -20,6 0,20 C20,6 10,-10 0,0 Z" fill="${encodeURIComponent(col)}"/></svg>`;
            img.className = 'ground-petal';
            img.style.left = (x - size) + 'px'; 
            img.style.top = (y - size + 2) + 'px'; 
            img.style.width = (size * 2) + 'px';
            img.style.transform = `rotate(${ang}rad) scale(${1.2 + Math.random()*0.2}, ${0.7 + Math.random()*0.2})`;
            img.onclick = () => {
                mImg.src = mem.url; mTitle.innerText = mem.title;
                modal.classList.add('active'); overlay.style.display = 'block';
            };
            document.getElementById('mainContainer').appendChild(img);
        }

        overlay.onclick = () => { modal.classList.remove('active'); overlay.style.display = 'none'; };
        
        // 关键：Resize 时重置所有坐标
        window.addEventListener('resize', () => {
            init();
            document.querySelectorAll('.ground-petal').forEach(el => el.remove());
        });
        
        window.onload = init;
        document.querySelectorAll('.content-left p').forEach((p, i) => p.style.animationDelay = `${(i + 1) * 0.4}s`);
    </script>
</body>
</html>