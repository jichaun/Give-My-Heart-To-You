<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title> WE</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #fdfdf0; /* 米色背景 */
            font-family: "Microsoft YaHei", sans-serif;
        }

        /* 布局容器 */
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: space-around;
        }

        /* 左侧文字区 */
        .content-left {
            width: 50%;
            padding-left: 10%;
            z-index: 10;
            pointer-events: none; /* 防止遮挡画布 */
        }

        .content-left h1 {
            font-size: 2.2rem;
            color: #333;
            margin-bottom: 40px;
        }

        .content-left p {
            font-size: 1rem;
            color: #555;
            line-height: 2.4;
            margin: 0;
            letter-spacing: 1px;
            opacity: 0;
            animation: fadeInText 2s ease forwards;
        }

        @keyframes fadeInText {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* 画布与地平线 */
        #treeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
        }

        .horizon {
            position: absolute;
            bottom: 20%;
            left: 10%;
            right: 10%;
            height: 2px;
            background-color: #333;
            z-index: 2;
        }

        /* 落地花瓣样式 (DOM元素) */
        .ground-petal {
            position: absolute;
            z-index: 6;
            cursor: pointer;
            /* 关键：CSS过渡实现温柔落地 */
            transition: top 0.6s cubic-bezier(0.25, 0.8, 0.25, 1), 
                        transform 0.6s cubic-bezier(0.25, 0.8, 0.25, 1), 
                        filter 0.3s;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.1)); 
            transform-origin: center bottom;
            opacity: 0.95;
        }

        /* 落地后的状态类 */
        .ground-petal.settled {
            opacity: 1;
        }

        .ground-petal:hover {
            transform: scale(1.5) rotate(0deg) !important; 
            filter: brightness(1.1) drop-shadow(0 5px 8px rgba(0,0,0,0.2));
            z-index: 1000;
            transition: transform 0.3s, filter 0.3s;
        }

        /* 照片弹窗样式 */
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 20px;
            border-radius: 24px;
            border: 1px solid rgba(255,255,255,0.5);
            box-shadow: 0 30px 60px rgba(0,0,0,0.15);
            text-align: center;
        }

        .modal.active {
            display: block;
            animation: zoomIn 0.4s ease;
        }

        .modal img {
            max-width: 320px;
            border-radius: 16px;
            border: 3px solid white;
        }

        .modal p {
            color: #333;
            margin-top: 15px;
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        @keyframes zoomIn {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* 遮罩层 */
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.2);
            z-index: 1999;
        }
    </style>
</head>
<body>

    <div class="overlay" id="overlay"></div>
    <div class="modal" id="modal">
        <img id="mImg" src="" alt="Memory">
        <p id="mTitle">美好的瞬间</p>
    </div>

    <div class="container" id="mainContainer">
        <div class="content-left">
            <h1>Hello, 陌生人。</h1>
            <p>纪念我们第一次跨年</p>
            <p>祝我们永远如初</p>
            <p>祝我们永远幸福</p>
            <p>像第一次见你那样</p>
            <p>第一、第二次跨年</p>
            <p>以后都是我们</p>
        </div>
        <div class="horizon"></div>
        <canvas id="treeCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('mainContainer');
        const modal = document.getElementById('modal');
        const overlay = document.getElementById('overlay');
        const mImg = document.getElementById('mImg');
        const mTitle = document.getElementById('mTitle');
        
        let width, height;
        let staticLeaves = []; // 树上的叶子
        let fallingLeaves = []; // 飘落中的叶子
        let groundHeightMap = []; // 地面高度图，用于堆积
        
        // --- 核心配置：照片库 ---
        // 这里的照片数量决定了会有多少片叶子掉落
        const photoGallery = [
            { url: '1.jpg', title: '第一次跨年' },
            { url: '4.jpg', title: '最美的你' },
            { url: '3.jpg', title: '最可爱的也是你' },
            { url: '2.jpg', title: '幸福的我们' },
            { url: '5.jpg', title: '真的好幸福' }
        ];
        
        let photosToDrop = []; // 待掉落队列

        const colorPalette = [
            { fill: '#ff69b4', stroke: '#ff1493' }, 
            { fill: '#ffb6c1', stroke: '#ff85a1' }, 
            { fill: '#ff4500', stroke: '#d13400' }, 
            { fill: '#ffd700', stroke: '#ffcc00' }, 
            { fill: '#fb6f92', stroke: '#ff4d6d' }  
        ];

        // --- 初始化 ---
        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            groundHeightMap = new Array(width).fill(0);
            
            // 重置待掉落队列
            photosToDrop = [...photoGallery];
            
            generateTreeLeaves();
            animate();
        }

        // 生成心形SVG DataURL
        function createHeartSVG(color) {
            return `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="-20 -20 40 40"><path d="M0,0 C-10,-10 -20,6 0,20 C20,6 10,-10 0,0 Z" fill="${encodeURIComponent(color)}"/></svg>`;
        }

        // --- 生成静态树叶 (树冠) ---
        function generateTreeLeaves() {
            staticLeaves = [];
            const treeX = width * 0.65;
            const treeY = height * 0.8;
            
            for (let i = 0; i < 1600; i++) {
                const t = Math.random() * Math.PI * 2;
                const r = Math.pow(Math.random(), 0.5) * 230; 
                const leafX = treeX + 16 * Math.pow(Math.sin(t), 3) * (r / 15);
                const leafY = (treeY - 320) - (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * (r / 15);
                
                // 避开树干底部
                if (leafY < treeY - 120) {
                    staticLeaves.push({ 
                        x: leafX, 
                        y: leafY, 
                        size: Math.random() * 8 + 4, 
                        colors: colorPalette[Math.floor(Math.random() * colorPalette.length)], 
                        angle: Math.random() * Math.PI, 
                        swingOffset: Math.random() * Math.PI * 2 
                    });
                }
            }
        }

        // --- 绘制最基础、不晃动的树干 ---
        function drawStandardTrunk(x, y) {
            ctx.fillStyle = '#1a1a1a';
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineCap = 'round'; // 保持连接处圆润

            // 1. 基础主干 (实心梯形)
            ctx.beginPath();
            ctx.moveTo(x - 14, y);
            ctx.quadraticCurveTo(x, y - 80, x - 4, y - 180); 
            ctx.lineTo(x + 4, y - 180); 
            ctx.quadraticCurveTo(x + 10, y - 80, x + 22, y); 
            ctx.fill();

            // 2. 固定的支撑树枝 (简单的二次曲线)
            const branches = [
                {sx: x, sy: y-120, ex: x-60, ey: y-220, w: 4.5},
                {sx: x, sy: y-110, ex: x+70, ey: y-210, w: 4},
                {sx: x, sy: y-180, ex: x-25, ey: y-260, w: 3},
                {sx: x, sy: y-190, ex: x+35, ey: y-250, w: 3}
            ];

            branches.forEach(b => {
                ctx.lineWidth = b.w;
                ctx.beginPath();
                ctx.moveTo(b.sx, b.sy);
                // 简单的抛物线
                ctx.quadraticCurveTo(b.sx + (b.ex-b.sx)/2, b.sy-20, b.ex, b.ey);
                ctx.stroke();
            });
        }

        // --- 动画循环 ---
        function animate() {
            ctx.clearRect(0, 0, width, height);
            const treeX = width * 0.65;
            const treeY = height * 0.8;
            const time = Date.now() * 0.0007;

            // 1. 绘制标准树干
            drawStandardTrunk(treeX, treeY);

            // 2. 绘制静态花瓣
            staticLeaves.forEach(leaf => {
                const swing = Math.sin(time + leaf.swingOffset) * 1.2;
                drawHeartCanvas(leaf.x + swing, leaf.y + swing, leaf.size, leaf.colors, 0.85, leaf.angle);

                // --- 核心逻辑：从队列取照片 ---
                if (photosToDrop.length > 0 && Math.random() > 0.995) { 
                    const photoData = photosToDrop.shift();
                    fallingLeaves.push({
                        x: leaf.x, y: leaf.y, size: leaf.size, colors: leaf.colors,
                        angle: leaf.angle, 
                        vx: (Math.random() * 0.6 - 0.3), 
                        vy: Math.random() * 0.2 + 0.3, 
                        phase: Math.random() * Math.PI * 2,
                        memory: photoData // 绑定照片
                    });
                }
            });

            // 3. 绘制掉落花瓣
            for (let i = fallingLeaves.length - 1; i >= 0; i--) {
                let p = fallingLeaves[i];
                p.x += p.vx + Math.sin(time * 2 + p.phase) * 0.3;
                p.y += p.vy;
                p.angle += 0.01;

                let currentX = Math.floor(p.x);
                if (currentX < 0) currentX = 0;
                if (currentX >= width) currentX = width - 1;
                
                // 计算当前地形高度
                let groundLevel = treeY - groundHeightMap[currentX];
                
                // 落地检测
                if (p.y >= groundLevel) {
                    const maxDist = 200;
                    // 如果飘太远，拉回树下
                    if (Math.abs(p.x - treeX) > maxDist) {
                        p.x = treeX + (p.x > treeX ? 1 : -1) * (maxDist - Math.random() * 20);
                        currentX = Math.floor(p.x);
                        groundLevel = treeY - groundHeightMap[currentX];
                    }

                    // 生成地面交互元素
                    createGroundPetal(p.x, groundLevel, p.size, p.colors.fill, p.angle, p.memory);

                    // 更新高度图 (堆积效果)
                    const pileRadius = 15;
                    const pileHeightAdd = 3;
                    for(let k = -pileRadius; k <= pileRadius; k++) {
                        let targetX = currentX + k;
                        if(targetX >= 0 && targetX < width) {
                            let addVal = pileHeightAdd * Math.exp(-(k*k)/50);
                            if(groundHeightMap[targetX] < 80) { // 限制最大堆积高度
                                groundHeightMap[targetX] += addVal;
                            }
                        }
                    }
                    fallingLeaves.splice(i, 1);
                    continue;
                }
                drawHeartCanvas(p.x, p.y, p.size, p.colors, 0.9, p.angle);
            }
            requestAnimationFrame(animate);
        }

        // Canvas 绘制心形
        function drawHeartCanvas(x, y, size, colors, alpha, angle) {
            ctx.save(); ctx.translate(x, y); ctx.rotate(angle); ctx.globalAlpha = alpha;
            const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            grd.addColorStop(0, colors.fill); grd.addColorStop(1, colors.stroke);
            ctx.beginPath(); ctx.moveTo(0, 0);
            ctx.bezierCurveTo(-size / 2, -size / 2, -size, size / 3, 0, size);
            ctx.bezierCurveTo(size, size / 3, size / 2, -size / 2, 0, 0);
            ctx.fillStyle = grd; ctx.fill(); ctx.restore();
        }

        // 创建地面交互花瓣
        function createGroundPetal(x, finalY, size, color, angle, memoryData) {
            const petal = document.createElement('img');
            petal.src = createHeartSVG(color);
            petal.className = 'ground-petal';
            
            const initialOffset = 15;
            // 初始位置略高
            petal.style.left = (x - size) + 'px'; 
            petal.style.top = (finalY - size + 5 - initialOffset) + 'px'; 
            petal.style.width = (size * 2) + 'px';
            petal.style.transform = `rotate(${angle}rad) scale(1, 1)`;

            container.appendChild(petal);
            
            // 强制重绘
            petal.getBoundingClientRect();

            // 计算最终压扁透视
            const finalScaleX = 1 + Math.random() * 0.3;
            const finalScaleY = 0.5 + Math.random() * 0.3;
            
            // 下一帧应用最终状态，触发 transition
            requestAnimationFrame(() => {
                petal.classList.add('settled');
                petal.style.top = (finalY - size + 5) + 'px';
                petal.style.transform = `rotate(${angle}rad) scale(${finalScaleX}, ${finalScaleY})`;
            });
            
            // 点击事件
            petal.onclick = () => {
                mImg.src = memoryData.url; 
                mTitle.innerText = memoryData.title;
                modal.classList.add('active');
                overlay.style.display = 'block';
            };
        }

        // 关闭弹窗
        overlay.onclick = () => { modal.classList.remove('active'); overlay.style.display = 'none'; };
        
        window.onload = init;
        window.onresize = () => { 
            width = canvas.width = window.innerWidth; 
            height = canvas.height = window.innerHeight; 
            groundHeightMap = new Array(width).fill(0); 
            photosToDrop = [...photoGallery]; 
            generateTreeLeaves(); 
        };
        
        // 文字延迟
        document.querySelectorAll('.content-left p').forEach((p, i) => p.style.animationDelay = `${(i + 1) * 0.4}s`);
    </script>
</body>
</html>