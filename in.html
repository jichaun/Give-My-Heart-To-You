<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WE - Mobile Optimized</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #fdfdf0; 
            font-family: "Microsoft YaHei", sans-serif;
            touch-action: manipulation; /* 优化移动端点击延迟 */
        }

        .container {
            position: relative; width: 100vw; height: 100vh;
            display: flex; 
            flex-direction: row; /* 电脑端默认横向 */
            align-items: center; justify-content: flex-start;
        }

        /* --- 手机端响应式排版 --- */
        @media (max-width: 768px) {
            .container { 
                flex-direction: column; /* 手机端改为纵向 */
                align-items: center; 
            }
            .content-left { 
                width: 90% !important; 
                padding: 12% 0 0 0 !important; 
                text-align: center; /* 文字居中 */
            }
            .content-left h1 { font-size: 1.6rem !important; margin-bottom: 15px !important; }
            .content-left p { font-size: 0.85rem !important; line-height: 1.8 !important; }
            .horizon { bottom: 15% !important; } /* 地平线位置微调 */
        }

        .content-left {
            width: 45%; padding-left: 8%; z-index: 10; pointer-events: none;
            position: relative;
        }

        .content-left h1 { font-size: 2.2rem; color: #333; margin-bottom: 30px; }
        .content-left p {
            font-size: 1rem; color: #555; line-height: 2.2; margin: 0;
            letter-spacing: 1px; opacity: 0; animation: fadeInText 2s ease forwards;
        }

        @keyframes fadeInText {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #treeCanvas { position: absolute; top: 0; left: 0; z-index: 5; }

        .horizon {
            position: absolute; bottom: 20%; left: 5%; right: 5%;
            height: 2px; background-color: #333; z-index: 2;
        }

        .ground-petal {
            position: absolute; z-index: 6; cursor: pointer;
            transition: top 0.5s cubic-bezier(0.25, 0.8, 0.25, 1), transform 0.5s ease;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.1)); 
            transform-origin: center bottom;
        }

        /* 照片弹窗适配 */
        .modal {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%); z-index: 2000;
            background: rgba(255, 255, 255, 0.45);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            padding: 15px; border-radius: 24px; border: 1px solid rgba(255,255,255,0.5);
            box-shadow: 0 25px 50px rgba(0,0,0,0.15); text-align: center;
            width: 85%; max-width: 340px;
        }
        .modal.active { display: block; animation: zoomIn 0.3s ease; }
        .modal img { width: 100%; border-radius: 16px; border: 3px solid white; box-sizing: border-box; }
        .modal p { color: #333; margin-top: 12px; font-weight: bold; font-size: 14px; }
        
        @keyframes zoomIn { from { transform: translate(-50%, -50%) scale(0.9); opacity: 0; } }
        .overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.25); z-index: 1999; }
    </style>
</head>
<body>

    <div class="overlay" id="overlay"></div>
    <div class="modal" id="modal">
        <img id="mImg" src="" alt="Memory">
        <p id="mTitle"></p>
    </div>

    <div class="container" id="mainContainer">
        <div class="content-left">
            <h1>Hello, 陌生人。</h1>
            <p>纪念我们第一次跨年</p>
            <p>祝我们永远如初</p>
            <p>祝我们永远幸福</p>
            <p>像第一次见你那样</p>
            <p>第一、第二次跨年</p>
            <p>以后都是我们</p>
        </div>
        <div class="horizon"></div>
        <canvas id="treeCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');
        const modal = document.getElementById('modal');
        const overlay = document.getElementById('overlay');
        const mImg = document.getElementById('mImg');
        const mTitle = document.getElementById('mTitle');
        
        let width, height, treeX, treeY, treeScale;
        let staticLeaves = [], fallingLeaves = [], groundHeightMap = [];
        
        const photoGallery = [
            { url: '1.jpg', title: '第一次跨年' },
            { url: '4.jpg', title: '最美的你' },
            { url: '3.jpg', title: '最可爱的也是你' },
            { url: '2.jpg', title: '幸福的我们' },
            { url: '5.jpg', title: '真的好幸福' }
        ];
        
        let photosToDrop = [];
        const colorPalette = [
            { fill: '#ff69b4', stroke: '#ff1493' }, { fill: '#ffb6c1', stroke: '#ff85a1' }, 
            { fill: '#ff4500', stroke: '#d13400' }, { fill: '#ffd700', stroke: '#ffcc00' }, 
            { fill: '#fb6f92', stroke: '#ff4d6d' }  
        ];

        // --- 核心：动态初始化坐标系统 ---
        function initLayout() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            groundHeightMap = new Array(width).fill(0);
            
            if (width > 768) {
                // 电脑端：树在右侧，保持原始比例
                treeX = width * 0.68;
                treeY = height * 0.8;
                treeScale = Math.min(width / 1400, 1.0);
            } else {
                // 手机端：树居中，根据屏幕宽度缩放
                treeX = width * 0.5;
                treeY = height * 0.82;
                treeScale = Math.max(width / 450, 0.6); // 限制最小缩放防止树太小
            }
            
            photosToDrop = [...photoGallery];
            generateLeaves();
        }

        function generateLeaves() {
            staticLeaves = [];
            const count = width > 768 ? 1600 : 800; // 手机端适当减少叶片数量提升性能
            for (let i = 0; i < count; i++) {
                const t = Math.random() * Math.PI * 2;
                const r = Math.pow(Math.random(), 0.5) * (230 * treeScale); 
                const lx = treeX + 16 * Math.pow(Math.sin(t), 3) * (r / 15);
                const ly = (treeY - 320 * treeScale) - (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * (r / 15);
                
                if (ly < treeY - 120 * treeScale) {
                    staticLeaves.push({ 
                        x: lx, y: ly, size: (Math.random() * 7 + 4) * treeScale, 
                        colors: colorPalette[Math.floor(Math.random() * colorPalette.length)], 
                        angle: Math.random() * Math.PI, 
                        swing: Math.random() * Math.PI * 2 
                    });
                }
            }
        }

        function drawTrunk() {
            ctx.fillStyle = '#1a1a1a';
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineCap = 'round';
            
            const baseW = 16 * treeScale;
            const trunkH = 180 * treeScale;

            ctx.beginPath();
            ctx.moveTo(treeX - baseW, treeY);
            ctx.quadraticCurveTo(treeX, treeY - trunkH/2, treeX - baseW/3, treeY - trunkH); 
            ctx.lineTo(treeX + baseW/3, treeY - trunkH); 
            ctx.quadraticCurveTo(treeX + baseW/2, treeY - trunkH/2, treeX + baseW*1.4, treeY); 
            ctx.fill();

            const bArr = [
                {s: [treeX, treeY-120*treeScale], e: [treeX-65*treeScale, treeY-230*treeScale], w: 5*treeScale},
                {s: [treeX, treeY-110*treeScale], e: [treeX+75*treeScale, treeY-220*treeScale], w: 4.5*treeScale},
                {s: [treeX, treeY-190*treeScale], e: [treeX-30*treeScale, treeY-270*treeScale], w: 3*treeScale},
                {s: [treeX, treeY-200*treeScale], e: [treeX+40*treeScale, treeY-260*treeScale], w: 3*treeScale}
            ];
            bArr.forEach(b => {
                ctx.lineWidth = b.w;
                ctx.beginPath();
                ctx.moveTo(b.s[0], b.s[1]);
                ctx.quadraticCurveTo(b.s[0] + (b.e[0]-b.s[0])/2, b.s[1]-30*treeScale, b.e[0], b.e[1]);
                ctx.stroke();
            });
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);
            const time = Date.now() * 0.0008;
            drawTrunk();

            staticLeaves.forEach(l => {
                const s = Math.sin(time + l.swing) * 1.5;
                drawHeart(l.x + s, l.y + s, l.size, l.colors, 0.85, l.angle);

                if (photosToDrop.length > 0 && Math.random() > 0.995) { 
                    const data = photosToDrop.shift();
                    fallingLeaves.push({
                        x: l.x, y: l.y, size: l.size, colors: l.colors,
                        angle: l.angle, vx: (Math.random() * 0.8 - 0.4), vy: 1.5, 
                        phase: Math.random() * Math.PI * 2, memory: data 
                    });
                }
            });

            for (let i = fallingLeaves.length - 1; i >= 0; i--) {
                let p = fallingLeaves[i];
                p.vy += 0.035; p.x += p.vx + Math.sin(time * 3 + p.phase) * 0.6; p.y += p.vy; p.angle += 0.05;
                let curX = Math.floor(p.x);
                if (curX >= 0 && curX < width) {
                    let gLevel = treeY - groundHeightMap[curX];
                    if (p.y >= gLevel) {
                        // 落地限制：确保落在树的周围
                        if (Math.abs(p.x - treeX) < 200 * treeScale) {
                            createGroundPetal(p.x, gLevel, p.size, p.colors.fill, p.angle, p.memory);
                            for(let k=-12; k<=12; k++){
                                if(curX+k >=0 && curX+k < width){
                                    groundHeightMap[curX+k] += 2.5 * Math.exp(-(k*k)/45);
                                }
                            }
                        }
                        fallingLeaves.splice(i, 1);
                        continue;
                    }
                }
                drawHeart(p.x, p.y, p.size, p.colors, 0.9, p.angle);
            }
            requestAnimationFrame(animate);
        }

        function drawHeart(x, y, size, col, alpha, ang) {
            ctx.save(); ctx.translate(x, y); ctx.rotate(ang); ctx.globalAlpha = alpha;
            const g = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            g.addColorStop(0, col.fill); g.addColorStop(1, col.stroke);
            ctx.beginPath(); ctx.moveTo(0, 0);
            ctx.bezierCurveTo(-size/2, -size/2, -size, size/3, 0, size);
            ctx.bezierCurveTo(size, size/3, size/2, -size/2, 0, 0);
            ctx.fillStyle = g; ctx.fill(); ctx.restore();
        }

        function createGroundPetal(x, y, size, col, ang, mem) {
            const img = document.createElement('img');
            img.src = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="-20 -20 40 40"><path d="M0,0 C-10,-10 -20,6 0,20 C20,6 10,-10 0,0 Z" fill="${encodeURIComponent(col)}"/></svg>`;
            img.className = 'ground-petal';
            img.style.left = (x - size) + 'px'; 
            img.style.top = (y - size + 2) + 'px'; 
            img.style.width = (size * 2) + 'px';
            img.style.transform = `rotate(${ang}rad) scale(${1.1 + Math.random()*0.2}, ${0.6 + Math.random()*0.2})`;
            img.onclick = () => {
                mImg.src = mem.url; mTitle.innerText = mem.title;
                modal.classList.add('active'); overlay.style.display = 'block';
            };
            document.getElementById('mainContainer').appendChild(img);
        }

        overlay.onclick = () => { modal.classList.remove('active'); overlay.style.display = 'none'; };
        
        window.addEventListener('resize', () => {
            initLayout(); 
            // 清理旧花瓣防止坐标错位
            document.querySelectorAll('.ground-petal').forEach(el => el.remove());
        });
        
        window.onload = initLayout;
        document.querySelectorAll('.content-left p').forEach((p, i) => p.style.animationDelay = `${(i + 1) * 0.4}s`);
    </script>
</body>
</html>